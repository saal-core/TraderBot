"""
Task Executor Service
Executes the multi-step plan generated by the Query Planner.
"""
import json
import asyncio
from typing import Dict, List, Any, AsyncGenerator

from src.services.database_handler import DatabaseQueryHandler
from src.services.internet_data_handler import InternetDataHandler
from src.config.llm_provider import get_streaming_llm
from src.utils.response_cleaner import clean_llm_response
from src.utils.toon_formatter import dataframe_to_toon

class TaskExecutor:
    """
    Executes a list of tasks from a query plan.
    """

    def __init__(
        self,
        db_handler: DatabaseQueryHandler,
        internet_handler: InternetDataHandler
    ):
        self.db_handler = db_handler
        self.internet_handler = internet_handler
        # LLM for analysis/explanation (higher temperature for natural text)
        self.explanation_llm = get_streaming_llm(temperature=0.7)
        print("âœ… Task Executor initialized")

    async def execute_plan_streaming(
        self, 
        plan: Dict[str, Any], 
        chat_history: List[Dict[str, str]]
    ) -> AsyncGenerator[str, None]:
        """
        Execute the plan step-by-step and stream results.
        
        Yields:
             SSE event strings (data: {...})
        """
        steps = plan.get("plan", [])
        if not steps:
            yield self._format_event("error", {"error": "Empty execution plan"})
            return


        # Variables to capture for final validation
        final_sql = None
        final_results = None

        # Context to store results from each step
        context = {}
        
        # yield self._format_event("status", {"message": f"ğŸ“‹ Executing plan with {len(steps)} steps..."})
        print(f"ğŸ“‹ Executing plan with {len(steps)} steps...")
        
        for step in steps:
            step_id = step.get("step")
            action = step.get("action")
            description = step.get("description")
            query_hint = step.get("query_hint")
            
            # yield self._format_event("status", {"message": f"Step {step_id}: {description}"})
            print(f"Step {step_id}: {description}")
            
            try:
                # Resolve dependencies in query hint
                # If query_hint contains placeholders like {indices from step 1}, 
                # we'll do a simple replacement if possible, or append context.
                final_query = query_hint
                if "depends_on" in step:
                    dependencies = step["depends_on"]
                    context_str = "\n".join([f"Step {d} Result: {json.dumps(context.get(d), default=str)}" for d in dependencies])
                    # Improve query context
                    if action in ["fetch_internet", "fetch_database"]:
                         final_query = f"{query_hint}\nContext from previous steps:\n{context_str}"
                
                step_result = None

                if action == "fetch_database":
                    # Generate SQL
                    # yield self._format_event("status", {"message": f"Step {step_id}: Generating SQL..."})
                    print(f"Step {step_id}: Generating SQL...")
                    sql_query = self.db_handler.generate_sql(final_query, chat_history)
                    
                    if sql_query.startswith("ERROR"):
                         raise Exception(sql_query)
                         
                    yield self._format_event("sql", {"content": sql_query})
                    
                    # Execute SQL
                    # yield self._format_event("status", {"message": f"Step {step_id}: Executing query..."})
                    print(f"Step {step_id}: Executing query...")
                    success, df, msg = self.db_handler.sql_executor.execute_query(sql_query)
                    
                    if not success:
                         raise Exception(msg)
                    
                    # Store result as list of dicts for context
                    step_result = df.to_dict(orient="records") if df is not None else []
                    context[step_id] = step_result
                    
                    # Capture for final event
                    final_sql = sql_query
                    final_results = step_result
                    
                    # Stream partial explanation for this step
                    # yield self._format_event("status", {"message": f"Step {step_id}: Analyzing results..."})
                    print(f"Step {step_id}: Analyzing results...")
                    # We accept the raw dataframe here
                    # For intermediate steps, we might not want full streaming explanation, 
                    # but let's give a summary or just store it. 
                    # For now, let's just confirm success.
                    # yield self._format_event("content", f"âœ… Step {step_id} Complete: Retrieved {len(step_result)} records.\n")
                    print(f"âœ… Step {step_id} Complete: Retrieved {len(step_result)} records.")

                elif action == "fetch_internet":
                     # yield self._format_event("status", {"message": f"Step {step_id}: Fetching market data..."})
                     print(f"Step {step_id}: Fetching market data...")
                     raw_data = self.internet_handler.fetch_raw_data(final_query, chat_history)
                     
                     if raw_data.startswith("Error"):
                         raise Exception(raw_data)
                         
                     step_result = raw_data
                     context[step_id] = step_result
                     # yield self._format_event("content", f"âœ… Step {step_id} Complete: Market data fetched.\n")
                     print(f"âœ… Step {step_id} Complete: Market data fetched.")

                elif action == "analyze" or action == "compare":
                     print(f"Step {step_id}: Analyzing & Comparing...")
                     
                     # Format context data for unified response generator
                     context_str = ""
                     for ctx_step_id, result in context.items():
                         context_str += f"\n--- Data from Step {ctx_step_id} ---\n"
                         if isinstance(result, list) and result:
                             # It's likely database rows - format as readable text
                             try:
                                 import pandas as pd
                                 df = pd.DataFrame(result)
                                 context_str += dataframe_to_toon(df, f"Step_{ctx_step_id}_Data")
                             except:
                                 context_str += str(result)
                         else:
                             context_str += str(result)
                     
                     # Use unified response generator
                     from src.services.unified_response_generator import get_response_generator
                     
                     generator = get_response_generator()
                     data = {"context": context_str}
                     
                     yield self._format_event("content", "ğŸ“Š **Analysis:**\n")
                     
                     # Stream analysis using unified generator
                     for chunk in generator.stream_response(
                         query=query_hint or description,
                         context_type="hybrid",
                         data=data
                     ):
                         yield self._format_event("content", chunk)
                           
                     step_result = "Analysis completed"
                     context[step_id] = step_result

                else:
                    yield self._format_event("error", {"error": f"Unknown action: {action}"})

            except Exception as e:
                error_msg = f"Step {step_id} Failed: {str(e)}"
                yield self._format_event("error", {"error": error_msg})
                return

            
        # Refined strategy: We need to capture SQL and Results during execution
        # For now, let's just send what we have if possible, or empty.
        # Ideally we should accumulate them in self.context or a separate list.
        
        # yield self._format_event("status", {"message": "Plan execution complete!"})
        print("Plan execution complete!")
        
        # Send completion event with metadata if available
        # Since we didn't track SQL/Results explicitly in a list to send, we might miss them in the UI for now.
        # But fixing the format is step 1.
        yield self._format_event("assistant_message_complete", {
            "query_type": "hybrid", # inferred
            "sql_query": final_sql,
            "results": final_results
        })
        
        yield self._format_event("stream_end", {})

    def _format_event(self, event_type: str, data: Any) -> str:
        """Format data as SSE event"""
        event_data = {"type": event_type}
        if event_type == "content":
            event_data["content"] = data
        else:
            event_data["data"] = data
            
        return f"data: {json.dumps(event_data, default=str)}\n\n"
